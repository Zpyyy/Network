# TCP流量控制

> 滑动窗口协议



## TCP数据包基本交互过程

- 收、发双方A和B会告知彼此的第一个发送字节的**初始序列号**，以后对每一个发送的字节都需要以初始序列号为**原点**进行编号（SEQ），同时需要对方来**确认**（ACK）每一个字节编号都已经成功接收。

- 双方初始序列号是由**OS动态生成的，随机的值**，一般每个TCP session都会有不一样的初始序列号，占四个字节（参加下图）。

  注意：

  - ==（1）三次握手里的SEQ是从0开始。==
  - ==（2）wireshark里的SEQ是已经计算过的相对值==

  

设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是rwnd = 400”（这里的rwnd表示receiver window）。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意：==TCP的窗口单位是字节，不是报文段。==TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1.（*大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。* ）

![img](http://image.hw3static.com/hi/staticimages/hi3msg/images/2018/0524/10/5b0622ec4dc44.jpg) 

- 从图中可以看出，B进行了三次流量控制。第一次把窗口减少到rwnd = 300，第二次又减到了rwnd=100，最后减到了0，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了ACK=1，只有在ACK=1时确认号字段才有意义。     
- TCP为每一个连接设有一个==持续计时器==。只要TCP连接的一方收到对方的零窗口通知就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（携有1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。 

## TCP传输策略

目前建立在TCP协议上的网络协议特别多，有telnet，ssh，有ftp，有http等等。这些协议又可以根据数据吞吐量来大致分成两大类：

1. 交互数据类型，例如telet，ssh，这种类型的协议在大多数情况下只是做小流量的数据交换，比如说按一下键盘，回显一些文字等等。
2. 数据成块类型， 例如ftp，这种类型的协议要求TCP能尽量的运载数据，把数据的吞吐量做到最大，并尽可能的提高效率。针对这两种情况，TCP给出了两种不同的策略来进行数据传输。

### 1. TCP的交互数据流

对于交互性要求比较高的应用，TCP给出两个策略来提高发送效率和减低网络负担：

1. 捎带ACK
2. Nagle算法（一次尽量多的发数据）



通常，在网络速度很快的情况下，比如用I/O接口进行telnet通信，当按下字母键并要求回显的时候，客户端和服务器将经历 

1. 发送按键数据

2. 服务器发送按键数据的ack 

3. 服务器端发送回显数据

4. 客户端发送回显数据的ACK

> 而其中的数据流量将是40bit + 41bit+41bit+40bit = 162bit，如果在广域网里面，这种小分组的TCP流量将会造成很大的网络负担。

#### 1.1 捎带ACK的发送方式

这个策略是说，当主机收到远程主机的TCP数据报之后，通常不马上发送ACK数据报，而是等上一个短暂的时间，如果这段时间里面主机还有发送到远程主机的TCP数据报，那么就把这个ACK数据报“捎带”着发送出去，把本来两个TCP数据报整合成一个发送。一般的，这个时间是200ms。可以明显地看到这个策略可以把TCP数据报的利用率提高很多。



#### 1.2.Nagle算法

上过bbs的人应该都会有感受，就是在网络慢的时候发贴，有时键入一串字符串以后，经过一段时间，客户端“发疯”一样突然回显出很多内容，就好像数据一下子传过来了一样，这就是Nagle算法的作用。

Nagle算法是说，当主机A给主机B发送了一个TCP数据报并进入等待主机B的ACK数据报的状态时，TCP的输出缓冲区里面只能有一个TCP数据报，并且，这个数据报不断地收集后来的数据，整合成一个大的数据报，等到B主机的ACK包一到，就把这些数据“一股脑”的发送出去。虽然这样的描述有些不准确，但还算形象和易于理解，我们同样可以体会到这个策略对于低减网络负担的好处。

在编写插口程序的时候，可以通过TCP_NODELAY来关闭这个算法。并且，使用这个算法看情况的，比如基于TCP的X窗口协议，如果处理鼠标事件时还是用这个算法，那么“延迟”可就非常大了。



### 2. TCP的成块数据流

对于FTP这样对于数据吞吐量有较高要求的要求，将总是希望每次尽量多的发送数据到对方主机，就算是有点“延迟”也无所谓。TCP也提供了一整套的策略来支持这样的需求。TCP协议中有16个bit表示“窗口”的大小，这是这些策略的核心。

#### 2.1.传输数据时ACK的问题

在解释滑动窗口前，需要看看ACK的应答策略，一般来说，发送端发送一个TCP数据报，那么接收端就应该发送一个ACK数据报。但是事实上却不是这样，发送端将会连续发送数据尽量填满接受方的缓冲区，而接受方对这些数据只要发送一个ACK报文来回应就可以了，这就是==ACK的累积特性==，这个特性大大减少了发送端和接收端的负担。

#### 2.2.滑动窗口

滑动窗口本质上是描述接受方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。

关于滑动窗口协议，书上还介绍了三个术语，分别是：

1. 窗口合拢：当窗口从左边向右边靠近的时候，这种现象发生在数据被发送和确认的时候。
2. 窗口张开：当窗口的右边沿向右边移动的时候，这种现象发生在接受端处理了数据以后。
3. 窗口收缩：当窗口的右边沿向左边移动的时候，这种现象不常发生。

TCP就是用这个窗口，慢慢的从数据的左边移动到右边，把处于窗口范围内的数据发送出去（但不用发送所有，只是处于窗口内的数据可以发送。）。这就是窗口的意义。窗口的大小是可以通过socket来制定的，4096并不是最理想的窗口大小，而16384则可以使吞吐量大大的 增加。

### 2.3.数据拥塞

上面的策略用于局域网内传输还可以，但是用在广域网中就可能会出现问题，最大的问题就是当传输时出现了瓶颈（比如说一定要经过一个slip低速链路）所产生的大量数据堵塞问题（拥塞），为了解决这个问题，TCP发送方需要确认连接双方的线路的数据最大吞吐量是多少。这就是所谓的拥塞窗口。

拥塞窗口的原理很简单，TCP发送方首先发送一个数据报，然后等待对方的回应，得到回应后就把这个窗口的大小加倍，然后连续发送两个数据报，等到对 方回应以后，再把这个窗口加倍（先是2的指数倍，到一定程度后就变成现行增长，这就是所谓的慢启动），发送更多的数据报，直到出现超时错误，这样，发送端 就了解到了通信双方的线路承载能力，也就确定了拥塞窗口的大小，发送方就用这个拥塞窗口的大小发送数据。要观察这个现象是非常容易的，我们一般在下载数据 的时候，速度都是慢慢“冲起来的”

以上就是TCP数据传输的大致流程，虽然并不细致，但是足以描述TCP的工作原理，重点是TCP的流量控制原理，滑动窗口，拥塞窗口，ACK累计确认等知识点。

------



### 滑动窗口的实现

在图中，我们可看出灰色1号2号3号包已经发送完毕，并且已经收到Ack。这些包就已经是过去式。4、5、6、7号包是黄色的，表示已经发送了。但是并没有收到对方的Ack，所以也不知道接收方有没有收到。8、9、10号包是绿色的。是我们还没有发送的。这些绿色也就是我们接下来马上要发送的包。 可以看出我们的窗口正好是7格。后面的11-16还没有被读进内存。要等4号-10号包有接下来的动作后，我们的包才会继续往下发送。 

> `已发送但还未收到对端ACK`和`未发送但对端允许发送`的这两部份数据称之为**发送窗口**
>
> `对端的WindowSize`是**滑动窗口**的大小

![实现](https://img2018.cnblogs.com/blog/1629488/201906/1629488-20190622120313249-1589098511.png)

### **正常情况**

可以看到4号包对方已经被接收到，所以被涂成了灰色。“窗口”就往右移一格，这里只要保证“窗口”是7格的。 我们就把11号包读进了我们的缓存。进入了“待发送”的状态。8、9号包已经变成了黄色，表示已经发送出去了。接下来的操作就是一样的了，确认包后，窗口往后移继续将未发送的包读进缓存，把“待发送“状态的包变为”已发送“。 

![正常情况](https://img2018.cnblogs.com/blog/1629488/201906/1629488-20190622120342786-1303756640.png)

### 丢包情况

有可能我们包发过去，对方的Ack丢了。也有可能我们的包并没有发送过去。从发送方角度看就是我们没有收到Ack。

![丢包](https://img2018.cnblogs.com/blog/1629488/201906/1629488-20190622120408388-1447718459.png)

发生的情况：一直在等Ack。如果一直等不到的话，我们也会把读进缓存的待发送的包也一起发过去。但是，这个时候我们的窗口已经发满了。所以并不能把12号包读进来，而是始终在等待5号包的Ack。

> **如果我们这个Ack始终不来怎么办呢？**

### 超时重发

这时候我们有个解决方法：`超时重传`
这里有一点要说明：这个Ack是要按顺序的。必须要等到5的Ack收到，才会把6-11的Ack发送过去。这样就保证了滑动窗口的一个顺序。

![超时重发](https://img2018.cnblogs.com/blog/1629488/201906/1629488-20190622120426493-2120202258.png)

这时候可以看出5号包已经接受到Ack，后面的6、7、8号包也已经发送过去已Ack。窗口便继续向后移动。  



可以用不同的机制来控制TCP报文段的发送时机。如：  

1. TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装一个TCP报文段发送出去；     
2. 由发送方的应用进程指明要求发送报文段，即TCP支持的推送操作；    
3.  发送方的一个计时器期限到了，这时就把已有的缓存数据装入报文段（但长度不能超过MSS）发送出去。     
4. Nagle算法：若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节发送出去，把后面到达的数据字节都缓存起来。当发送方接收对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段再发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后，才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。
   - Nagle算法还规定：当到达的数据已达到发送窗口大小的一半或已经达到报文段的最大长度时，就立即发送一个报文段。     

### **糊涂窗口综合征**

#### 原因

这个问题可以归结为==小包==的问题，就是由于发送端和接收端上的处理不一致，导致网络上产生很多的小包，之前也介绍过避免网络上产生过多小包的措施，比如**Nagle算法**。

- 在滑动窗口机制下，如果发送端和接收端速率很不一致，也会产生这种比较犯傻的状态：发送方发送的数据，只要一个大大的头部，携带数据很少。
- 对于接收端来讲，如果接收很慢，一次接收1个字节或者几个字节，这个时候接收端 缓冲区很快就会被填满，然后窗口通告为0字节，这个时候发送端停止发送，应用程序收上去1个字节后，发出窗口通告为1字节，发送方收到通告之后，发出1个字节的数据，这样周而复始，传输效率会非常低。
- 同时如果发送端程序一次发送一个字节，虽然窗口足够大，但是发送仍是一个字节一个字节的传输，效率很低

#### 解决措施

要解决这个问题，可让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收方缓存已有一半空闲的空间。只要出现这两种情况，接收方就发回确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据报积累成足够大的报文段，或达到接收方缓存的空间的一半大小。  

#### TCP协议栈的优化措施

1. 接收端

   1. 窗口为0时，应用程序有收上去数据，但是并不立即会送窗口为1的通告，而是等待窗口大小满足一定的条件之后【==能够接收一个最大报文，或者缓冲区的一半==】，再来发送窗口通告，这样就不会产生小报文。

      如下图，通告0窗口之后，下一次窗口update就变成2048了， 其实这样并没有降低传输的效率，只是将不断的发送小包换成发送大包而已。

   ![img](https://img-blog.csdn.net/20160908083720058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

   2.  Delay ACK，这个机制可以参考前面的文章，接收端不立即回，是否有数据回复进行捎带ACK，这个也能降低ACK的数量
   3. 累计ACK，并不是每一个数据都回复ACK，可以多个数据段一起回复ACK

2. 发送端

   TCP提供了Nagle算法

   1. 对于从应用程序中接收到的第一块数据【==没有任何等待ACK的包==】，立即发送，一个字节的数据也需要发送出去

   2. 对于后面的数据，协议栈会进行累计并等待，或者收到一个接收端发出一个ACK，或者累计到一个最大报文段，然后再发送数据

      除了Nagle算法发送端还可以通过1个字节的数据来探测Windowsize的变化
      

