# TCP流量控制

> 滑动窗口协议



## TCP数据包基本交互过程

- 收、发双方A和B会告知彼此的第一个发送字节的**初始序列号**，以后对每一个发送的字节都需要以初始序列号为**原点**进行编号（SEQ），同时需要对方来**确认**（ACK）每一个字节编号都已经成功接收。

- 双方初始序列号是由**OS动态生成的，随机的值**，一般每个TCP session都会有不一样的初始序列号，占四个字节（参加下图）。

  注意：

  - ==（1）三次握手里的SEQ是从0开始。==
  - ==（2）wireshark里的SEQ是已经计算过的相对值==

  

设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是rwnd = 400”（这里的rwnd表示receiver window）。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意：==TCP的窗口单位是字节，不是报文段。==TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1.（*大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。* ）

![img](http://image.hw3static.com/hi/staticimages/hi3msg/images/2018/0524/10/5b0622ec4dc44.jpg) 

- 从图中可以看出，B进行了三次流量控制。第一次把窗口减少到rwnd = 300，第二次又减到了rwnd=100，最后减到了0，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了ACK=1，只有在ACK=1时确认号字段才有意义。     
- TCP为每一个连接设有一个==持续计时器==。只要TCP连接的一方收到对方的零窗口通知就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（携有1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。 

### 滑动窗口的实现

在图中，我们可看出灰色1号2号3号包已经发送完毕，并且已经收到Ack。这些包就已经是过去式。4、5、6、7号包是黄色的，表示已经发送了。但是并没有收到对方的Ack，所以也不知道接收方有没有收到。8、9、10号包是绿色的。是我们还没有发送的。这些绿色也就是我们接下来马上要发送的包。 可以看出我们的窗口正好是7格。后面的11-16还没有被读进内存。要等4号-10号包有接下来的动作后，我们的包才会继续往下发送。 

> `已发送但还未收到对端ACK`和`未发送但对端允许发送`的这两部份数据称之为**发送窗口**
>
> `对端的WindowSize`是**滑动窗口**的大小

![实现](https://img2018.cnblogs.com/blog/1629488/201906/1629488-20190622120313249-1589098511.png)

### **正常情况**

可以看到4号包对方已经被接收到，所以被涂成了灰色。“窗口”就往右移一格，这里只要保证“窗口”是7格的。 我们就把11号包读进了我们的缓存。进入了“待发送”的状态。8、9号包已经变成了黄色，表示已经发送出去了。接下来的操作就是一样的了，确认包后，窗口往后移继续将未发送的包读进缓存，把“待发送“状态的包变为”已发送“。 

![正常情况](https://img2018.cnblogs.com/blog/1629488/201906/1629488-20190622120342786-1303756640.png)

### 丢包情况

有可能我们包发过去，对方的Ack丢了。也有可能我们的包并没有发送过去。从发送方角度看就是我们没有收到Ack。

![丢包](https://img2018.cnblogs.com/blog/1629488/201906/1629488-20190622120408388-1447718459.png)

发生的情况：一直在等Ack。如果一直等不到的话，我们也会把读进缓存的待发送的包也一起发过去。但是，这个时候我们的窗口已经发满了。所以并不能把12号包读进来，而是始终在等待5号包的Ack。

> **如果我们这个Ack始终不来怎么办呢？**

### 超时重发

这时候我们有个解决方法：`超时重传`
这里有一点要说明：这个Ack是要按顺序的。必须要等到5的Ack收到，才会把6-11的Ack发送过去。这样就保证了滑动窗口的一个顺序。

![超时重发](https://img2018.cnblogs.com/blog/1629488/201906/1629488-20190622120426493-2120202258.png)

这时候可以看出5号包已经接受到Ack，后面的6、7、8号包也已经发送过去已Ack。窗口便继续向后移动。  



可以用不同的机制来控制TCP报文段的发送时机。如：  

1. TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装一个TCP报文段发送出去；     
2. 由发送方的应用进程指明要求发送报文段，即TCP支持的推送操作；    
3.  发送方的一个计时器期限到了，这时就把已有的缓存数据装入报文段（但长度不能超过MSS）发送出去。     
4. Nagle算法：若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节发送出去，把后面到达的数据字节都缓存起来。当发送方接收对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段再发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后，才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。
   - Nagle算法还规定：当到达的数据已达到发送窗口大小的一半或已经达到报文段的最大长度时，就立即发送一个报文段。     

### **糊涂窗口综合征**

#### 原因

这个问题可以归结为==小包==的问题，就是由于发送端和接收端上的处理不一致，导致网络上产生很多的小包，之前也介绍过避免网络上产生过多小包的措施，比如**Nagle算法**。

- 在滑动窗口机制下，如果发送端和接收端速率很不一致，也会产生这种比较犯傻的状态：发送方发送的数据，只要一个大大的头部，携带数据很少。
- 对于接收端来讲，如果接收很慢，一次接收1个字节或者几个字节，这个时候接收端 缓冲区很快就会被填满，然后窗口通告为0字节，这个时候发送端停止发送，应用程序收上去1个字节后，发出窗口通告为1字节，发送方收到通告之后，发出1个字节的数据，这样周而复始，传输效率会非常低。
- 同时如果发送端程序一次发送一个字节，虽然窗口足够大，但是发送仍是一个字节一个字节的传输，效率很低

#### 解决措施

要解决这个问题，可让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收方缓存已有一半空闲的空间。只要出现这两种情况，接收方就发回确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据报积累成足够大的报文段，或达到接收方缓存的空间的一半大小。  

#### TCP协议栈的优化措施

1. 接收端

   1. 窗口为0时，应用程序有收上去数据，但是并不立即会送窗口为1的通告，而是等待窗口大小满足一定的条件之后【==能够接收一个最大报文，或者缓冲区的一半==】，再来发送窗口通告，这样就不会产生小报文。

      如下图，通告0窗口之后，下一次窗口update就变成2048了， 其实这样并没有降低传输的效率，只是将不断的发送小包换成发送大包而已。

   ![img](https://img-blog.csdn.net/20160908083720058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

   2.  Delay ACK，这个机制可以参考前面的文章，接收端不立即回，是否有数据回复进行捎带ACK，这个也能降低ACK的数量
   3. 累计ACK，并不是每一个数据都回复ACK，可以多个数据段一起回复ACK

2. 发送端

   TCP提供了Nagle算法

   1. 对于从应用程序中接收到的第一块数据【==没有任何等待ACK的包==】，立即发送，一个字节的数据也需要发送出去

   2. 对于后面的数据，协议栈会进行累计并等待，或者收到一个接收端发出一个ACK，或者累计到一个最大报文段，然后再发送数据

      除了Nagle算法发送端还可以通过1个字节的数据来探测Windowsize的变化
      

